{"name":"StringScanner","body":"StringScanner performs lexical scanning operations on a string.\r\nInspired by [Ruby's StringScanner class](http://ruby-doc.org/core/classes/StringScanner.html)\r\n\r\n\r\nHow To Use\r\n----------\r\n\r\nInstantiate a new `StringScanner` by passing its constructor the string to scan.\r\n\r\n    var StringScanner = require(\"StringScanner\");\r\n    var ss = new StringScanner(\"abc123 def456\");\r\n    // #<StringScanner 0/13 @ \"abc12...\">\r\n\r\nFor the following examples, `ss` represents the `StringScanner` instance\r\ndefined above.\r\n\r\n### bol / beginningOfLine\r\nReturns `true` if the scan pointer is at the beginning of a line (right after\r\n`\\n`) or the beginning of the string, `false` otherwise.\r\n\r\n    ss.reset()    // #<StringScanner 0/13 @ \"abc12...\">\r\n    ss.pointer()  // 0\r\n    ss.bol()      // true\r\n    ss.scan(/./)  // \"a\"\r\n    ss.pointer()  // 1\r\n    ss.bol()      // false\r\n\r\n### captures\r\nReturns an Array containing the contents of the capturing groups in the last\r\nevaluated pattern match.\r\n\r\n    ss.reset()              // #<StringScanner 0/13 @ \"abc12...\">\r\n    ss.check(/.*(..) (..)/  // \"abc123 de\"\r\n    ss.captures()           // [\"23\",\"de\"]\r\n    ss.check(/\\w+/)         // \"abc123\"\r\n    ss.captures()           // []\r\n    ss.check(/\\s+/)         // null\r\n    ss.captures()           // []\r\n\r\n\r\n### check(pattern)\r\n*Note: this method alters last match results*\r\n\r\nChecks if a `scan` of the given pattern would succeed without advancing the\r\nscan pointer. Returns the portion of the string matched on successful match,\r\n`null` otherwise.\r\n\r\n    ss.reset()           // #<StringScanner 0/13 @ \"abc12...\">\r\n    ss.check(/[a-z]+/i)  // \"abc\"\r\n    ss.check(/[a-z]+/i)  // \"abc\"\r\n    ss.scan(/[a-z]+/i)   // \"abc\"\r\n    ss.check(/[a-z]+/i)  // null\r\n    ss.check(/[\\d\\s]+/)  // \"123 \"\r\n\r\n### checkUntil(pattern)\r\n*Note: this method alters last match results*\r\n\r\nChecks if a `scanUntil` would succeed without advancing the scan pointer.\r\nReturns the portion of the string being scanned from the scan pointer to the\r\nend of the matched string on successful match, `null` otherwise.\r\n\r\n    ss.reset()           // #<StringScanner 0/13 @ \"abc12...\">\r\n    ss.checkUntil(/\\s/)  // \"abc123 \"\r\n    ss.checkUntil(/\\s/)  // \"abc123 \"\r\n    ss.checkUntil(/r/)   // null\r\n    ss.scanUntil(/e/)    // \"abc123 de\"\r\n    ss.checkUntil(/\\s/)  // null\r\n\r\n### clone / dup\r\nCreates a duplicate of this instance of `StringScanner`.\r\n\r\n### concat(str)\r\nAppends the given string to the string being scanned.\r\n\r\n    ss.reset()            // #<StringScanner 0/13 @ \"abc12...\">\r\n    ss.checkUntil(/h/)    // null\r\n    ss.concat(\" ghi789\")  // #<StringScanner 0/20 @ \"abc12...\"\r\n    ss.checkUntil(/h/)    // \"abc123 def456 gh\"\r\n\r\n### eos / endOfString\r\nReturns `true` if the scan pointer is at the end of the string being scanned,\r\n`false` otherwise.\r\n\r\n    ss.reset()     // #<StringScanner 0/13 @ \"abc12...\">\r\n    ss.pointer()   // 0\r\n    ss.eos()       // false\r\n    ss.scan(/.*/)  // \"abc123 def456\"\r\n    ss.pointer()   // 13\r\n    ss.eos()       // true\r\n\r\n### exists(pattern) / exist(pattern)\r\n*Note: this method alters last match results*\r\n\r\n*Warning: this method may return `0` on a successful operation. Use `===`\r\ncomparision to `null` for failure check, for example: `ss.exists(/a/i)===null`*\r\n\r\nChecks if the given pattern matches anywhere after the current scan pointer.\r\nThis will determine if a `scanUntil` operation will succeed.  Returns the\r\nnumber of characters between the scan pointer and the position in which the\r\nmatch was found on success, `null` otherwise.\r\n\r\n    ss.reset()\r\n    // ----\r\n    ss.exists(/c/)   // 2\r\n    ss.match()       // \"c\"\r\n    ss.matched()     // true\r\n    // ----\r\n    ss.exists(/a/)   // 0\r\n    ss.match()       // \"a\"\r\n    ss.matched()     // true\r\n    // ----\r\n    ss.exists(/b*/)  // 0\r\n    ss.match()       // \"\"\r\n    ss.matched()     // true\r\n    // ----\r\n    ss.exists(/m/)   // null\r\n    ss.match()       // null\r\n    ss.matched()     // false\r\n\r\n### getch / getChar\r\n*Note: this method alters last match results*\r\n\r\n*Note: Ruby equivalent: `get_byte`*\r\n\r\n`scan`s one character and returns it; exactly equivalent to `scan(/./)`.\r\n\r\n    ss.reset()    // #<StringScanner 0/13 @ \"abc12...\">\r\n    ss.getch()    // \"a\"\r\n    ss.reset()    // #<StringScanner 0/13 @ \"abc12...\">\r\n    ss.scan(/./)  // \"a\"\r\n\r\n### match\r\n*Note: Ruby equivalent: `matched`*\r\n\r\nReturns the last string matched or `null` if the last attempted match failed.\r\n\r\n    ss.reset()           // #<StringScanner 0/13 @ \"abc12...\">\r\n    ss.scan(/[a-z]+/i)   // \"abc\"\r\n    ss.match()           // \"abc\"\r\n    ss.check(/[a-z]+/i)  // null\r\n    ss.match()           // null\r\n\r\n### matches(pattern)\r\n*Note: Ruby equivalent: `match?`*\r\n\r\nChecks if a scan of the given pattern would succeed without advancing the scan\r\npointer. Returns the length of the string matched on successful match, `null`\r\notherwise.\r\n\r\n    ss.reset()             // #<StringScanner 0/13 @ \"abc12...\">\r\n    ss.matches(/[a-z]+/i)  // 3\r\n    ss.matches(/[a-z]+/i)  // 3\r\n    ss.scan(/[a-z]+/i)     // \"abc\"\r\n    ss.matches(/[a-z]+/i)  // null\r\n    ss.matches(/[\\d\\s]+/)  // 4\r\n\r\n### matched\r\n*Note: Ruby equivalent: `matched?`*\r\n\r\nReturns `true` if the last attempted match was successful, `false` otherwise.\r\n\r\n    ss.reset()      // #<StringScanner 0/13 @ \"abc12...\">\r\n    ss.scan(/\\w+/)  // \"abc123\"\r\n    ss.matched()    // true\r\n    ss.scan(/\\w+/)  // null\r\n    ss.matched()    // false\r\n\r\n### matchSize\r\n*Warning: this method may return `0` on a successful operation. Use `===`\r\ncomparision to `null` for failure check, for example: `ss.matchSize()===null`*\r\n\r\nReturns the length of the most recently matched string if the most recent match\r\nattempt succeeded, `null` otherwise.\r\n\r\n    ss.reset()       // #<StringScanner 0/13 @ \"abc12...\">\r\n    ss.scan(/\\w+/)   // \"abc123\"\r\n    ss.matchSize()   // 6\r\n    ss.check(/\\w*/)  // \"\"\r\n    ss.matchSize()   // 0\r\n    ss.check(/\\w+/)  // null\r\n    ss.matchSize()   // null\r\n\r\n### peek(len)\r\nReturns *len* characters after the scan pointer, or the rest of the string,\r\nwhichever is shorter.\r\n\r\n    ss.reset()      // #<StringScanner 0/13 @ \"abc12...\">\r\n    ss.scan(/.*d/)  // \"abc123 d\"\r\n    ss.peek(3)      // \"ef4\"\r\n    ss.peek(9001)   // \"ef456\"\r\n    ss.peek(0)      // \"\"\r\n    ss.peek(-3)     // \"\"\r\n\r\n### pointer / position\r\nReturns the scan pointer position as an integer.\r\n\r\n    ss.reset()            // #<StringScanner 0/13 @ \"abc12...\">\r\n    ss.pointer()          // 0\r\n    ss.scan(/\\w+\\d+\\s+/)  // \"abc123 \"\r\n    ss.pointer()          // 7\r\n    ss.scan([a-z]+)       // \"def\"\r\n    ss.pointer()          // 10\r\n\r\n### setPointer(pos)\r\nManually move the scan pointer to *pos* characters from the beginning of the\r\nstring. The scan pointer is bounded between zero and the scanning string's\r\nlength. Returns the position to which the scan pointer was moved. `setPointer`\r\nneither resets nor modifies the last match results.\r\n\r\n    ss.reset()         // #<StringScanner 0/13 @ \"abc12...\">\r\n    ss.setPointer(4)   // 4\r\n    ss.scan(/\\d+/)     // \"23\"\r\n    ss.pointer()       // 6\r\n    ss.setPointer(-4)  // 0\r\n    ss.setPointer(99)  // 13\r\n\r\n### reset\r\nMoves the scan pointer back to the beginning of the string being scanned and\r\nclears the last match results.\r\n\r\n    ss.reset()            // #<StringScanner 0/13 @ \"abc12...\">\r\n    ss.scanUntil(/(\\s)/)  // \"abc123 \"\r\n    ss.pointer()          // 7\r\n    ss.match()            // \"abc123 \"\r\n    ss.captures()         // [\" \"]\r\n    ss.reset()            // #<StringScanner 0/13 @ \"abc12...\">\r\n    ss.pointer()          // 0\r\n    ss.match()            // null\r\n    ss.captures()         // []\r\n\r\n### rest\r\nReturns the portion of the string being scanned after the scan pointer.\r\n\r\n    ss.reset()          // #<StringScanner 0/13 @ \"abc12...\">\r\n    ss.scanUntil(/\\s/)  // \"abc123 \"\r\n    ss.rest()           // \"def456\"\r\n\r\n### scan(pattern)\r\n*Note: this method alters last match results*\r\n\r\nAttempts to match the given pattern at the position of the scan pointer.\r\nReturns the matched string and advances the string pointer upon successful\r\nmatch. A failed match will result in a `null` value being returned.\r\n\r\n    ss.reset()         // #<StringScanner 0/13 @ \"abc12...\">\r\n    ss.scan(/[a-z]+/)  // \"abc\"\r\n    ss                 // #<StringScanner 3/13 @ \"abc12...\">\r\n    ss.scan(/[a-z]+/)  // null\r\n    ss                 // #<StringScanner 3/13 @ \"abc12...\">\r\n    ss.scan(/[0-9]+/)  // \"123\"\r\n    ss                 // #<StringScanner 6/13 @ \"abc12...\">\r\n\r\n### scanUntil(pattern)\r\n*Note: this method alters last match results*\r\n\r\nAttempts to match the pattern against the string being scanned. On a successful\r\nmatch, the scan pointer is advanced to the end of the matched portion of the\r\nstring and the portion of the string being scanned up to and including the\r\nmatched string is returned. On a failed match, `null` is returned.\r\n\r\n    ss.reset()         // #<StringScanner 0/13 @ \"abc12...\">\r\n    ss.scanUntil(/ /)  // \"abc123 \"\r\n    ss.scanUntil(/f/)  // \"def\"\r\n    ss.scanUntil(/f/)  // null\r\n\r\n### skip(pattern)\r\n*Note: this method alters last match results*\r\n\r\nPerforms a `scan`, returning the length of the matched string on successful\r\nmatch, `null` otherwise.\r\n\r\n    ss.reset()         // #<StringScanner 0/13 @ \"abc12...\">\r\n    ss.skip(/[a-z]+/)  // 3\r\n    ss.skip(/[a-z]+/)  // null\r\n    ss.skip(/[0-9]+/)  // 3\r\n\r\n### skipUntil(pattern)\r\n*Note: this method alters last match results*\r\n\r\nPerforms a `scanUntil`, returning the length of the matched string on\r\nsuccessful match, `null` otherwise.\r\n\r\n    ss.reset()         // #<StringScanner 0/13 @ \"abc12...\">\r\n    ss.skipUntil(/ /)  // 7\r\n    ss.skipUntil(/f/)  // 3\r\n    ss.skipUntil(/f/)  // null\r\n\r\n### string\r\nReturns the entire string being scanned.\r\n\r\n    ss.string()  // \"abc123 def456\"\r\n    ss.getch()   // \"a\"\r\n    ss.string()  // \"abc123 def456\"\r\n\r\n### terminate / clear\r\nAdvances the scan pointer to the end of the string being scanned and resets the\r\nlast match results.\r\n\r\n    ss.reset()      // #<StringScanner 0/13 @ \"abc12...\">\r\n    ss.getch()      // \"a\"\r\n    ss.pointer()    // 1\r\n    ss.terminate()  // #<StringScanner fin>\r\n    ss.pointer()    // 13\r\n    ss.eos()        // true\r\n    ss.match()      // null\r\n\r\nKnown Issues\r\n------------\r\n\r\nNot really an issue, but `StringScanner` assumes the global flag (g) is\r\ndisabled on any RegExp objects passed as patterns to any of its methods. If the\r\nglobal flag is enabled, `StringScanner` may produce unexpected results.\r\n\r\nAdditional Info\r\n---------------\r\n\r\nI am always open for feature requests or any feedback.  I can be reached at\r\n[Github](http://github.com/michaelficarra).\r\n\r\nThanks to the Ruby community for the original idea and implementation.","tagline":"string-tokenizing CommonJS module; mimicks Ruby's StringScanner API","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}